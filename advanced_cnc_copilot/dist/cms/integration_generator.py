"""
Universal Integration Generator ðŸ”Œ
Responsibility:
1. Accept an IntegrationSpec (JSON).
2. Generate a robust Python Connector Module.
3. Handle Auth, Retries, and Logging automatically.
"""
import os
import json
from dataclasses import dataclass
from typing import Dict, List, Optional

@dataclass
class IntegrationSpec:
    name: str           # e.g. "Slack"
    base_url: str       # e.g. "https://slack.com/api"
    auth_type: str      # "Bearer", "ApiKey", "Basic", "None"
    auth_key_env: str   # e.g. "SLACK_BOT_TOKEN"
    endpoints: Dict[str, str] # e.g. {"send_message": "POST /chat.postMessage"}

class IntegrationGenerator:
    def __init__(self, output_dir="backend/integrations"):
        self.output_dir = output_dir
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

    def generate(self, spec: IntegrationSpec) -> str:
        """
        Generates the Python code for the connector.
        """
        class_name = f"{spec.name}Connector"
        filename = f"connector_{spec.name.lower()}.py"
        
        # Template Construction
        code = f'''"""
{spec.name} Integration Connector ðŸ”—
Generated by Universal Integration Generator
"""
import os
import requests
import logging
from typing import Dict, Any, Optional

logger = logging.getLogger("{class_name}")

class {class_name}:
    def __init__(self):
        self.base_url = "{spec.base_url}"
        self.auth_token = os.getenv("{spec.auth_key_env}")
        
        if not self.auth_token and "{spec.auth_type}" != "None":
            logger.warning("{spec.auth_key_env} not found. Integration disabled.")
            self.enabled = False
        else:
            self.enabled = True

    def _get_headers(self) -> Dict[str, str]:
        headers = {{"Content-Type": "application/json"}}
        if "{spec.auth_type}" == "Bearer":
            headers["Authorization"] = f"Bearer {{self.auth_token}}"
        elif "{spec.auth_type}" == "ApiKey":
            headers["X-Api-Key"] = self.auth_token
        return headers

    def _request(self, method: str, endpoint: str, data: Optional[Dict] = None) -> Any:
        if not self.enabled:
            logger.warning("Call to disabled integration ignored.")
            return None
            
        url = f"{{self.base_url}}{{endpoint}}"
        try:
            logger.info(f"Calling {{method}} {{url}}")
            resp = requests.request(method, url, json=data, headers=self._get_headers(), timeout=10)
            resp.raise_for_status()
            return resp.json()
        except Exception as e:
            logger.error(f"Integration Error: {{e}}")
            return None
'''
        
        # Generate Methods for each endpoint
        for func_name, route_def in spec.endpoints.items():
            method, path = route_def.split(" ")
            code += f'''
    def {func_name}(self, payload: Dict[str, Any]) -> Any:
        """
        Auto-generated method for {method} {path}
        """
        return self._request("{method}", "{path}", payload)
'''

        # Global Instance
        code += f'''
# Singleton
{spec.name.lower()}_conn = {class_name}()
'''
        
        # Write to file
        full_path = os.path.join(self.output_dir, filename)
        with open(full_path, "w", encoding="utf-8") as f:
            f.write(code)
            
        return full_path

# Example Usage (when run directly)
if __name__ == "__main__":
    # Test Generation: Slack
    slack_spec = IntegrationSpec(
        name="Slack",
        base_url="https://slack.com/api",
        auth_type="Bearer",
        auth_key_env="SLACK_BOT_TOKEN",
        endpoints={
            "send_message": "POST /chat.postMessage",
            "get_history": "GET /conversations.history"
        }
    )
    gen = IntegrationGenerator()
    path = gen.generate(slack_spec)
    print(f"Generated Slack Connector at: {path}")
